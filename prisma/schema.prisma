generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum WalletType {
  Physical
  Virtual
}

enum PaymentType {
  Cash
  Installment
}


model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  username  String
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Wallet           Wallet[]
  Person           Person[]
  WalletExit       WalletExit[]
  BillToReceive    BillToReceive[]
  BillToPay        BillToPay[]
  ReceivedPayments ReceivedPayments[]
  WalletEntry      WalletEntry[]
}

model Person {
  id            Int             @id @default(autoincrement())
  name          String
  phone         String
  BillToPay     BillToPay[]
  BillToReceive BillToReceive[]
  userId        Int
  user          User            @relation(fields: [userId], references: [id])
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

model Wallet {
  id          Int           @id @default(autoincrement())
  description String
  balance     Float
  type        WalletType
  userId      Int
  user        User          @relation(fields: [userId], references: [id])
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  WalletEntry WalletEntry[]
  WalletExit  WalletExit[]
}

model WalletEntry {
  id               Int                @id @default(autoincrement())
  description      String
  amount           Float
  wallet           Wallet             @relation(fields: [walletId], references: [id])
  walletId         Int
  userId           Int
  user             User               @relation(fields: [userId], references: [id])
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  ReceivedPayments ReceivedPayments[]
}

model ReceivedPayments {
  id              Int           @id @default(autoincrement())
  paymentDate     DateTime
  amountReceived  Float
  walletEntry     WalletEntry   @relation(fields: [walletEntryId], references: [id])
  walletEntryId   Int           @unique
  billToReceive   BillToReceive @relation(fields: [billToReceiveId], references: [id])
  billToReceiveId Int
  userId          Int
  user            User          @relation(fields: [userId], references: [id])
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model BillToReceive {
  id               Int                @id @default(autoincrement())
  description      String
  value            Float
  person           Person             @relation(fields: [personId], references: [id])
  personId         Int
  userId           Int
  user             User               @relation(fields: [userId], references: [id])
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  ReceivedPayments ReceivedPayments[]
}

model WalletExit {
  id            Int           @id @default(autoincrement())
  exitDate      DateTime
  description   String
  amount        Float
  wallet        Wallet         @relation(fields: [walletId], references: [id])
  walletId      Int
  userId        Int
  user          User           @relation(fields: [userId], references: [id])
  billToPay     BillToPay?     @relation(fields: [billToPayId], references: [id])
  billToPayId   Int?
  installment   Installment?   @relation(fields: [installmentId], references: [id])
  installmentId Int?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Installment {
  id           Int            @id @default(autoincrement())
  dueDate      DateTime
  value        Float
  isPaid       Boolean        @default(false)
  billToPay    BillToPay      @relation(fields: [billToPayId], references: [id])
  billToPayId  Int
  WalletExits  WalletExit[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
}

model BillToPay {
  id           Int            @id @default(autoincrement())
  description  String
  value        Float? 
  dueDate      DateTime?
  paymentType  PaymentType?
  personId     Int? 
  person       Person?         @relation(fields: [personId], references: [id])
  isPaid       Boolean        @default(false)
  userId       Int
  user         User           @relation(fields: [userId], references: [id])
  installments Installment[]
  walletExits  WalletExit[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
}